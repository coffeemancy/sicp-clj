(ns ch1.p2
  (:require [clojure.test :refer :all]))

;; EXERCISE 1.9
;; Illustrate process and identify as iterative or recursive.
;; recursive process, recursive procedure
(defn plus [a b]
  (if (zero? a)
    b
    (inc (plus (dec a) b))))

;; iterative process, recursive procedure
(defn plus [a b]
  (if (zero? a)
    b
    (plus (dec a) (inc b))))

;; EXERCISE 1.10
;; Ackermann's function is defined:
(defn A [x y]
  (cond (zero? y) 0
        (zero? x) (* 2 y)
        (= y 1) 2
        :else (A (- x 1)
                 (A x (- y 1)))))

;; Evaluate:
(A 1 10)
(A 2 4)
(A 3 3)

(defn test-math [f F]
  (let [ns (range 3 6)]
    (filter (fn [n] (not (= (f n) (F n)))) ns)))

;; Give precise mathematical defintions:
(defn f [n] (A 0 n))
(test-math f
           (fn [n]
             ;; 2*n
             (* 2 n)))

(defn g [n] (A 1 n))
(test-math g
           (fn [n]
             ;; 2*A(1, n-1)
             (* 2 (A 1 (- n 1)))))


(defn h [n] (A 2 n))
(test-math h
           (fn [n]
             ;; A(1, A(2, n-1))
             (A 1 (A 2 (- n 1)))))

(defn k [n] (* 5 n n))
(test-math k
           (fn [n]
             ;; 5*n^2
             (* 5 n n)))

;; EXERCISE 1.11
;; Given:
;;   f(n) = n if n < 3
;;        = f(n-1)+2*f(n-2)+3*f(n-3) if n >= 3
;; Write a recursive process.
(defn f [n]
  (letfn [(g [x m]
            (* x (f (- m x))))]
    (if (< n 3)
        n
        (+ (g 1 n) (g 2 n) (g 3 n)))))

(map f (range 0 10))

;; Write an interative process.
(defn f [n]
  (letfn [(f-iter [a b c i]
            (if (zero? i)
                a ;; done, return accumulator
                (f-iter b c (+ c (* 2 b) (* 3 a)) (- i 1))))]
    (if (< n 3) n (f-iter 0 1 2 n))))

(map f (range 0 10))

;; EXERCISE 1.12
;; Pascal's triangle: 1 on edge, each number inside sum of two above it.
;; Write a recursive process to determine value at row and column.
(defn pascal [row column]
  (if (or (= row 1)
          (= row 2)
          (= column 1)
          (= column row))
      1
      (+ (pascal (- row 1) (- column 1))
         (pascal (- row 1) column))))

(map
 (fn [x] (mapv (partial pascal x) (range 1 (+ x 1))))
 (range 1 6))

;; EXERCISE 1.13
;; Prove Fib(n) closest to phi^n/sqrt(5) where:
;;   phi = (1+sqrt(5))/2
;;   Hint: let psi = (1-sqrt(5))/2
;; Prove: Fib(n) = (phi^n-psi^n)/sqrt(5)
(defn fib [n]
  (cond (= n 0) 0
        (= n 1) 1
        :else (+ (fib (- n 1)) (fib (- n 2)))))

(def phi (/ (+ 1 (Math/sqrt 5)) 2))

(def psi (/ (- 1 (Math/sqrt 5)) 2))

(defn prove [n]
  (int (/ (- (Math/pow phi n) (Math/pow psi n)) (Math/sqrt 5))))

(let [ns (range 1 10)]
  (map fib ns))

(let [ns (range 1 10)]
  (map prove ns))

; check for some numbers
(let [ns (range 1 10)]
  (filter
    (fn [n] (> (Math/abs (- (fib n) (prove n))) 0.001))
    (range 1 5)))

; fib(0) and fib(1) cases turn out
(prove 0)
(prove 1)

; otherwise, blah, blah, blah
; http://www.billthelizard.com/2009/12/sicp-exercise-113-fibonacci-and-golden.html

;; EXERCISE 1.14 -- INCOMPLETE
;; Draw the tree illustrating count-change.
;; What are orders of growth of space and number steps as amount
;;   of change increases?

;; EXERCISE 1.15
;; Given:
(defn p [x]
  (letfn [(cube [x] (* x x x))]
    (- (* 3 x) (* 4 (cube x)))))

(defn sine [angle]
  (if (not (> (Math/abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))

;; a. How many times is p applied when (sine 12.15) is evaluated?
(sine 12.15)

(/ 12.15 (Math/pow 3.0 5.0))

; expands
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.05))))))

; p is applied 5 times

;; b. What is order of growth in space and number of steps (as a function of
;;      a) used by process generated by sine procedure when (sine a) is
;;      evaluted?

;; The angle divided by a power of three must be less than 0.1 to stop, so:
;;   theta/(3^n) = 0.1 -> 10*theta = 3^n -> n = log(10*theta)/log(3)
;; It grows with the ternary log of the angle, so Theta(log n)

;; EXERCISE 1.16
;; Devise iterative exponentiation process using successive squaring and
;;   using a logarithmic number of steps. Hint: use invariant
(defn square [x] (* x x))

(defn fast-expt [b n]
  (cond (zero? n) 1
        (even? n) (square (fast-expt b (/ n 2)))
        :else (* b (fast-expt b (- n 1)))))

(defn expt-iter [b n]
  (letfn [(iter [a b n]
            (cond (zero? n) a
                  (even? n) (iter a (square b) (/ n 2))
                  :else (iter (* a b) b (- n 1))))]
    (iter 1 b n)))

(fast-expt 3 30)
(expt-iter 3 30)

(let [b 3 n 30]
  (- (fast-expt b n) (expt-iter b n)))

;; EXERCISE 1.17
;; Given:
(defn mult [a b]
  (if (zero? b)
      0
      (+ a (mult a (- b 1)))))

(mult 20 300)

;; Define double and halve:
(defn dbl [x] (+ x x))
(defn halve [x] (/ x 2))

;; Design multiplication procedure like fast-expt using Theta(log n) steps.
(defn fast-mult [b n]
  (cond (zero? n) 0
        (even? n) (dbl (fast-mult b (halve n)))
        :else (+ n (fast-mult n (- b 1)))))

(fast-mult 20 300)

;; EXERCISE 1.18
;; Devise procedure generating iterative process for multiplying integers
;;   in terms of adding, doubling, and halving, using Theta(log n) steps.
(defn mult-iter [b n]
  (letfn [(iter [a b n]
            (cond (zero? n) a
                  (even? n) (iter a (dbl b) (halve n))
                  :else (iter (+ a b) b (- n 1))))]
    (iter 0 b n)))

(mult-iter 20 300)


;; EXERCISE 1.19
;; Complete fib-iter procedure running in Theta(log n) steps
(defn fib [n]
  (letfn [(fib-iter [a b p q counter]
            (cond (zero? counter) b
                  (even? counter)
                    (fib-iter a
                              b
                              ;; compute p'
                              (+ (square p) (square q))
                              ;; compute q'
                              (+ (* 2 p q) (square q))
                              (/ counter 2))
                  :else (fib-iter (+ (* b q) (* a q) (* a p))
                                  (+ (* b p) (* a q))
                                  p
                                  q
                                  (- counter 1))))]
    (fib-iter 1 0 0 1 n)))

(let [ns (range 1 10)]
  (map fib ns))

(let [ns (range 1 10)]
  (map prove ns))

;; EXERCISE 1.20
;; Illustrate process generated in evaluating (gcd 206 40) using substitution
;;   method, indicating remainder operations actually performed.
;; How many remainder operations are actually performed in:
;;   normal-order evaluation?
;;   applicative-order evaluation?
(defn gcd [a b]
  (if (zero? b)
      a
      (gcd b (rem a b))))
(gcd 206 40)

; normal-order does rem N times
; TODO

; applicative-order does rem 4 times
(rem 206 40)
(rem 40 6)
(rem 6 4)
(rem 4 2)
(gcd (gcd (gcd (gcd 4 0) 2) 4) 6)

;; EXERCISE 1.21
;; Use smallest-divisor for some nums
(defn divides? [a b]
  (zero? (rem b a)))

(defn smallest-divisor [n]
  (letfn [(find-divisor [n test-divisor]
            (cond (> (square test-divisor) n) n
                  (divides? test-divisor n) test-divisor
                  :else (find-divisor n (+ test-divisor 1))))]
    (find-divisor n 2)))

(let [ns [199 1999 19999]]
  (map smallest-divisor ns))

;; EXERCISE 1.22 -- INCOMPLETE
;; Implement a timed-prime-test
(defn prime? [n]
  (= n (smallest-divisor n)))

(defn expmod [base exp m]
  (cond (zero? exp) 1
        (even? exp)
          (rem (square (expmod base (/ exp 2) m)) m)
        :else
          (rem (* base (expmod base (- exp 1) m)) m)))

(defn random [n]
  (.nextInt (java.util.Random.) n))

(defn fermat-test [n]
  (letfn [(try-it [a]
            (= (expmod a n n) a))]
    (try-it (+ 1 (random (- n 1))))))

(defn fast-prime? [n times]
  (cond (zero? times) true
        (fermat-test n) (fast-prime? n (- times 1))
        :else false))

; cheat, use macro as more idiomatic clojure
(with-out-str (time 4))

;; Write a search-for-primes checking primality consecutive odd integers
;;   in specified range. Find and time three smallest primes larger than:
;;     1000,
;;     10000,
;;     100000,
;;     1000000

(defn search-for-primes [n]
  )

(with-out-str (time (fast-prime? 1000 3)))

(let [ns [10E2 10E3 10E4 10E5]]
  (-> ns
      (with-out-str (time (partial fast-prime? :times 3)))))

;; Does timing data bear out growth of Theta(sqrt(n))?

;; Is result compatible with notion that programs run in time proportional to
;;   number of steps required for computation?

;; EXERCISE 1.23 -- INCOMPLETE


;; EXERCISE 1.24 -- INCOMPLETE


;; EXERCISE 1.25 -- INCOMPLETE


;; EXERCISE 1.26 -- INCOMPLETE


;; EXERCISE 1.27 -- INCOMPLETE


;; EXERCISE 1.28 -- INCOMPLETE

